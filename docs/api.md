# Basic Reactivity

The reactivity system is centered around objects called `DataPort`s (sometimes called "signals" in other libraries). A dataport is simply an object with this interface:

```ts
interface DataPort<T> {
    (): T;          // get the value of the port and logs it as a dependency
    (newVal: T): T; // set the value of the port
    sample(): T;    // gets the value of the port but does not log it as a dependency
    readonly [dataPortSymbol]: true;
}
```

The functions below all work in some way or another with dataports.

## `D.state.value`

```ts
function value<T>(init: T): DataPort<T>;
```

`D.state.value(init)` is shorthand for `D.state.datavalue(init, false)`.

## `D.state.data`

```ts
function data<T>(init: T): DataPort<T>;
```

`D.state.data(init)` is shorthand for `D.state.datavalue(init, true)`.

## `D.state.datavalue`

```ts
function datavalue<T>(init: T, updateOnEqual: boolean): DataPort<T>;
```

Creates a dataport  which is logged as a dependency of the active watch context when read, and triggers an update of all dependent contexts when written to.

The `init` parameter controls the initial value of the port, and the `updateOnEqual` parameter controls whether writing a new value which is `===` to the old value should trigger an update of dependent watchers.

### Example Usage

```ts
const value = D.state.value(0) //could also have used D.state.datavalue(0, false)

value() //gets value, returns 0 at this point
value(1) //sets value to 1
value() //gets value, returns 1 at this point
```

## `D.state.watch`

```ts
function watch(fn: () => void): Destructable
```

Calls `fn` and logs all `datavalue`s read during the execution of `fn`. Whenever any of these `datavalue`s is updated, `fn` will be reexecuted. Dependencies are collected fresh on each reexecution.

## `D.state.ignore`

```ts
function ignore<T>(inner: () => T): T;
```

When used within a `D.state.watch`, calls `inner` but does not collect accessed datavalues as dependencies. Returns the result of `inner()`.

## `D.state.makePort`

```ts
function makePort<T>(getter: () => T, setter: (val: T) => void): DataPort<T>;
```

This is a utility function for turning a getter/setter pair into an object obeying the dataport interface.

Note that unlike the dataports generated by `D.state.value`, `D.state.data`, and `D.state.datavlue`, the dataports generated by this function do *not* interact with the reactivity system. Calling `()` on a dataport from `makePort` just calls the getter and doesn't automatically add anything to the state system, and calling `(val)` just calls the setter and doesn't trigger an update of any watchers.

Note however that if you get or set `datavalue`-generated ports in `getter` or `setter`, then these read or written ports will act as usual as part of the dependency system.

## Basic DOM

## `D.dom.mountAt`

```ts
function mountAt(el: Element, inner: () => void): void;
```

Create a new element creation context at `el`. Element creation calls inside `inner` will be added as children of `el`.

## `D.dom.elements`

Object (technically a proxy, but it works like an object) mapping tagName to an element creation function. e.g.,

```ts
const div = D.dom.elements.div
```

This function can be used in several ways:

```ts

div() // add <div></div>

div("text") // add <div>text</div>

div("<b>escape</b>") // add <div>&lt;b&lt;escape&lt;/b&gt;</div>

div({style:"color:red"}) // add <div style="color:red" />

div(()=>{ // add <div></div>
	div({style:"color:red"}) // then add <div style="color:red"></div> inside
})
// So the full result is <div><div style="color:red"></div></div>

div(()=>{ // add <div style="color:green"></div>
	div({style:"color:red"}) // then add <div style="color:red"></div> inside
})
// So the full result is <div style="color:green"><div style="color:red"></div></div>
```

**Note that unlike JSX, hyperscript and similar libraries, Dynein element creation functions both return the generated node <u>AND</u> add it to the DOM**.

This allows using JS control flow structures like `if`, `for`, `while`, etc. to build HTML. e.g,

```ts
const {div, span} = D.dom.elements

D.dom.mountAt(document.body, ()=>{
	for (let i = 0; i<5; i++) {
		if (i % 2 == 0) {
			div(i)
		} else {
			span(i)
		}
	}
})
```

results in

```html
<body>
	<div>0</div>
	<span>1</span>
	<div>2</div>
	<span>3</span>
	<div>4</div>
</body>
```

## `D.dom.text`

```ts
declare type Primitive = string | number | boolean | undefined | null;

function text(val: Primitive | (() => Primitive)): Node;
```

If `val` is a primitive, inserts a text node with `val?.toString() ?? ""`.

If `val` is a function, sets up a watcher to watch the value of `val()` and update the inserted text node when `val()` changes.

Returns the created text node.

## `D.dom.html`

```ts
function html(html: string): void;
```

Inserts the specified HTML at the current position.

## `D.dom.node`

```ts
function node<T extends Node>(node: T): T;
```

Inserts the specified node at the current position and returns it.

## `D.dom.replacer`

```ts
function replacer(inner: () => void): void;
```

Runs `inner` in the current DOM creation context and also tracks dependencies like `D.state.watch`. When a dependency update is triggered, the dependency list is reset, all of the contents of the `replacer` area are cleared, `inner` is reexecuted, the dependencies are collected again, and the new nodes are added to the DOM.
