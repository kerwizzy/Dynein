# Dynein

Dynein is a small yet powerful library for creating reactive DOM apps.

**⚠️⚠️ EXPERIMENTAL / NOT FOR PRODUCTION USE ⚠️⚠️**

## Features

 * Zero dependencies
 * Tiny size (DOM + reactive state under 4 kB gzip)
 * No virtual DOM or diff/patch step
 * No JSX or custom compiler -- just plain JS (or TS) code.

## A Quick Example

```javascript
import * as D from "dynein"

const { button, h1 } = D.elements
const $text = D.addText

D.mountBody(()=>{
	const count = D.createSignal(0)
	h1("Hello World!")

	$text(()=>"Count = "+count())

	button({
		onclick:()=>{
			count(count()+1)
		}
	}, "Increment")
})

```
# Basic Reactivity

The reactivity system is centered around objects called `Signal`s. A signal is simply an object with this interface:

```ts
interface Signal<T> {
    (): T;          // get the value of the signal and records it as a dependency of whatever reactive context we're in
    (newVal: T): T; // set the value of the signal
}
```

The functions below all work in some way or another with signals.

## `D.createSignal`

```ts
function createSignal<T>(init: T, updateOnEqual?: boolean = false): D.Signal<T>;
```

Creates a signal which is logged as a dependency of the active watch context when read, and triggers an update of all dependent contexts when written to.

The `init` parameter controls the initial value of the signal, and the `updateOnEqual` parameter controls whether writing a new value which is `===` to the old value should trigger an update of dependent effects.

### Example Usage

```ts
const value = D.createSignal(0)

value() //gets value, returns 0 at this point
value(1) //sets value to 1
value() //gets value, returns 1 at this point
```

## `D.createEffect`

```ts
function createEffect(fn: () => void): Destructable
```

Calls `fn` and logs all `signal`s read during the execution of `fn`. Whenever any of these `signal`s is updated, `fn` will be reexecuted. Dependencies are collected fresh on each reexecution.

## `D.untrack`

```ts
function untrack<T>(inner: () => T): T;
```

When used within a `D.createEffect`, calls `inner` but does not collect accessed signals as dependencies. Returns the result of `inner()`.

## `D.toSignal`

```ts
function toSignal<T>(getter: () => T, setter: (val: T) => void): D.Signal<T>;
```

This is a utility function for turning a getter/setter pair into an object obeying the signal interface.

Note that unlike the signals generated by `D.createSignal`, the signals generated by this function do *not* interact with the reactivity system. Calling `()` on a signal from `toSignal` just calls the getter and doesn't automatically add anything to the state system, and calling `(val)` just calls the setter and doesn't trigger an update of any effects.

Note however that if you get or set `createSignal`-generated signals in `getter` or `setter`, then these read or written signals will act as usual as part of the dependency system.

# Basic DOM

## `D.addPortal`

```ts
function addPortal(parentNode: Node, inner: () => void): void
function addPortal(parentNode: Node, beforeNode: Node | null, inner: () => void): void
```

Create a new element creation context at `parentNode`. Element creation calls inside `inner` will be added as children of `parentNode`.

## `D.elements`

Object (technically a proxy, but it works like an object) mapping tagName to an element creation function. e.g.,

```ts
const div = D.elements.div
```

This function can be used in several ways:

```ts

div() // add <div></div>

div("text") // add <div>text</div>

div("<b>escape</b>") // add <div>&lt;b&lt;escape&lt;/b&gt;</div>

div({style:"color:red"}) // add <div style="color:red" />

div(()=>{ // add <div></div>
	div({style:"color:red"}) // then add <div style="color:red"></div> inside
})
// So the full result is <div><div style="color:red"></div></div>

div(()=>{ // add <div style="color:green"></div>
	div({style:"color:red"}) // then add <div style="color:red"></div> inside
})
// So the full result is <div style="color:green"><div style="color:red"></div></div>
```

**Note that unlike JSX, hyperscript and similar libraries, Dynein element creation functions both return the generated node <u>AND</u> add it to the DOM**.

This allows using JS control flow structures like `if`, `for`, `while`, etc. to build HTML. e.g,

```ts
const {div, span} = D.elements

D.portalInto(document.body, ()=>{
	for (let i = 0; i<5; i++) {
		if (i % 2 == 0) {
			div(i)
		} else {
			span(i)
		}
	}
})
```

results in

```html
<body>
	<div>0</div>
	<span>1</span>
	<div>2</div>
	<span>3</span>
	<div>4</div>
</body>
```

## `D.addText`

```ts
declare type Primitive = string | number | boolean | undefined | null;

function addText(val: Primitive | (() => Primitive)): Node;
```

If `val` is a primitive, inserts a text node with `val?.toString() ?? ""`.

If `val` is a function, sets up an effect to watch the value of `val()` and update the inserted text node when `val()` changes.

Returns the created text node.

## `D.addHTML`

```ts
function addHTML(html: string): void;
```

Inserts the specified HTML at the current position.

## `D.addNode`

```ts
function addNode<T extends Node>(node: T): T;
```

Inserts the specified node at the current position and returns it.

## `D.addDynamic`

```ts
function addDynamic(inner: () => void): void;
```

Runs `inner` in the current DOM creation context and also tracks dependencies like `D.createEffect`. When a dependency update is triggered, the dependency list is reset, all of the contents of the `addDynamic` area are cleared, `inner` is reexecuted, the dependencies are collected again, and the new nodes are added to the DOM.
